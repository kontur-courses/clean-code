using FluentAssertions;
using NUnit.Framework;

namespace Markdown.Tests;

[TestFixture]
public class MDTests
{
    [TestCase(
        @"Текст, _окруженный с двух сторон_ одинарными символами подчерка, должен помещаться в HTML-тег",
        "Текст, <em>окруженный с двух сторон</em> одинарными символами подчерка, должен помещаться в HTML-тег<br/>")]
    [TestCase(
        @"__Выделенный двумя символами текст__ должен становиться полужирным с помощью тега <strong>.",
        @"<strong>Выделенный двумя символами текст</strong> должен становиться полужирным с помощью тега <strong>.<br/>")]
    [TestCase(
        @"Любой символ можно экранировать, чтобы он не считался частью разметки.\_Вот это\_, не должно выделиться тегом \<em>.",
        @"Любой символ можно экранировать, чтобы он не считался частью разметки._Вот это_, не должно выделиться тегом \<em>.<br/>")]
    [TestCase(
        @"Символ экранирования исчезает из результата, только если экранирует что-то. Здесь сим\волы экранирования\ \должны остаться.\",
        @"Символ экранирования исчезает из результата, только если экранирует что-то. Здесь сим\волы экранирования\ \должны остаться.\<br/>")]
    [TestCase(
        @"Символ экранирования тоже можно экранировать: \\_вот это будет выделено тегом_ <em>",
        @"Символ экранирования тоже можно экранировать: \<em>вот это будет выделено тегом</em> <em><br/>")]
    [TestCase(@"Внутри __двойного выделения _одинарное_ тоже__ работает.",
        @"Внутри <strong>двойного выделения <em>одинарное</em> тоже</strong> работает.<br/>")]
    [TestCase(
        @"Но не наоборот — внутри _одинарного __двойное__ не_ работает.",
        @"Но не наоборот — внутри <em>одинарного __двойное__ не</em> работает.<br/>")]
    [TestCase(
        @"Подчерки внутри текста c цифрами_12_3 не считаются выделением и должны оставаться символами подчерка",
        @"Подчерки внутри текста c цифрами_12_3 не считаются выделением и должны оставаться символами подчерка<br/>")]
    [TestCase(
        @"Однако выделять часть слова они могут: и в _нач_але, и в сер_еди_не, и в кон_це._",
        @"Однако выделять часть слова они могут: и в <em>нач</em>але, и в сер<em>еди</em>не, и в кон<em>це.</em><br/>")]
    [TestCase(
        @"В то же время выделение в ра_зных сл_овах не работает.",
        @"В то же время выделение в ра_зных сл_овах не работает.<br/>")]
    [TestCase(
        @"__Непарные_ символы в рамках одного абзаца не считаются выделением.",
        @"__Непарные_ символы в рамках одного абзаца не считаются выделением.<br/>")]
    [TestCase(
        @"За подчерками, начинающими выделение, должен следовать непробельный символ. Иначе эти_ подчерки_ не считаются выделением и остаются просто символами подчерка.",
        @"За подчерками, начинающими выделение, должен следовать непробельный символ. Иначе эти_ подчерки_ не считаются выделением и остаются просто символами подчерка.<br/>")]
    [TestCase(
        @"Подчерки, заканчивающие выделение, должны следовать за непробельным символом. Иначе эти _подчерки _не считаются_ окончанием выделения и остаются просто символами подчерка.",
        @"Подчерки, заканчивающие выделение, должны следовать за непробельным символом. Иначе эти _подчерки <em>не считаются</em> окончанием выделения и остаются просто символами подчерка.<br/>")]
    [TestCase(
        @"В случае __пересечения _двойных__ и одинарных_ подчерков ни один из них не считается выделением.",
        @"В случае __пересечения _двойных__ и одинарных_ подчерков ни один из них не считается выделением.<br/>")]
    [TestCase(
        @"Если внутри подчерков пустая строка ____, то они остаются символами подчерка.",
        @"Если внутри подчерков пустая строка ____, то они остаются символами подчерка.<br/>")]
    [TestCase(
        @"# Заголовок __с _разными_ символами__",
        @"<h1>Заголовок <strong>с <em>разными</em> символами</strong></h1><br/>")]
    public void Render_Should_ReturnCorrectHtml(string text, string expected)
    {
        var actual = MD.Render(text);
        actual.Should().Be(expected);
    }
}
using FluentAssertions;
using NUnit.Framework;
using System;
using System.Diagnostics;

namespace Markdown.Tests;

[TestFixture]
public class MDTests
{
    [TestCase(
        @"Текст, _окруженный с двух сторон_ одинарными символами подчерка, должен помещаться в HTML-тег",
        "Текст, <em>окруженный с двух сторон</em> одинарными символами подчерка, должен помещаться в HTML-тег<br/>",
        TestName = "Обычный курсив")]
    [TestCase(
        @"__Выделенный двумя символами текст__ должен становиться полужирным с помощью тега <strong>.",
        @"<strong>Выделенный двумя символами текст</strong> должен становиться полужирным с помощью тега <strong>.<br/>",
        TestName = "Обычный жирный")]
    [TestCase(
        @"Любой символ можно экранировать, чтобы он не считался частью разметки.\_Вот это\_, не должно выделиться тегом \<em>.",
        @"Любой символ можно экранировать, чтобы он не считался частью разметки._Вот это_, не должно выделиться тегом \<em>.<br/>",
        TestName = "Экранирование")]
    [TestCase(
        @"Символ экранирования исчезает из результата, только если экранирует что-то. Здесь сим\волы экранирования\ \должны остаться.\",
        @"Символ экранирования исчезает из результата, только если экранирует что-то. Здесь сим\волы экранирования\ \должны остаться.\<br/>",
        TestName = "Некорректное экранирование")]
    [TestCase(
        @"Символ экранирования тоже можно экранировать: \\_вот это будет выделено тегом_ <em>",
        @"Символ экранирования тоже можно экранировать: \<em>вот это будет выделено тегом</em> <em><br/>",
        TestName = "Экранирование экранирования")]
    [TestCase(@"Внутри __двойного выделения _одинарное_ тоже__ работает.",
        @"Внутри <strong>двойного выделения <em>одинарное</em> тоже</strong> работает.<br/>",
        TestName = "Italic внутри Bold")]
    [TestCase(
        @"Но не наоборот — внутри _одинарного __двойное__ не_ работает.",
        @"Но не наоборот — внутри <em>одинарного __двойное__ не</em> работает.<br/>",
        TestName = "Bold внутри Italic")]
    [TestCase(
        @"Подчерки внутри текста c цифрами_12_3 не считаются выделением и должны оставаться символами подчерка",
        @"Подчерки внутри текста c цифрами_12_3 не считаются выделением и должны оставаться символами подчерка<br/>",
        TestName = "Выделение части числа")]
    [TestCase(
        @"Однако выделять часть слова они могут: и в _нач_але, и в сер_еди_не, и в кон_це._",
        @"Однако выделять часть слова они могут: и в <em>нач</em>але, и в сер<em>еди</em>не, и в кон<em>це.</em><br/>",
        TestName = "Выделение части слова")]
    [TestCase(
        @"В то же время выделение в ра_зных сл_овах не работает.",
        @"В то же время выделение в ра_зных сл_овах не работает.<br/>",
        TestName = "Теги в разных словах")]
    [TestCase(
        @"__Непарные_ символы в рамках одного абзаца не считаются выделением.",
        @"__Непарные_ символы в рамках одного абзаца не считаются выделением.<br/>",
        TestName = "Непарные теги")]
    [TestCase(
        @"За подчерками, начинающими выделение, должен следовать непробельный символ. Иначе эти_ подчерки_ не считаются выделением и остаются просто символами подчерка.",
        @"За подчерками, начинающими выделение, должен следовать непробельный символ. Иначе эти_ подчерки_ не считаются выделением и остаются просто символами подчерка.<br/>",
        TestName = "Пробел после открывающего тега")]
    [TestCase(
        @"Подчерки, заканчивающие выделение, должны следовать за непробельным символом. Иначе эти _подчерки _не считаются_ окончанием выделения и остаются просто символами подчерка.",
        @"Подчерки, заканчивающие выделение, должны следовать за непробельным символом. Иначе эти _подчерки <em>не считаются</em> окончанием выделения и остаются просто символами подчерка.<br/>",
        TestName = "Пробел перед закрывающим тегом")]
    [TestCase(
        @"В случае __пересечения _двойных__ и одинарных_ подчерков ни один из них не считается выделением.",
        @"В случае __пересечения _двойных__ и одинарных_ подчерков ни один из них не считается выделением.<br/>",
        TestName = "Пересечение тегов Italic и Bold")]
    [TestCase(
        @"Если внутри подчерков пустая строка ____, то они остаются символами подчерка.",
        @"Если внутри подчерков пустая строка ____, то они остаются символами подчерка.<br/>",
        TestName = "Пустая строка между тегами")]
    [TestCase(
        @"# Заголовок __с _разными_ символами__",
        @"<h1>Заголовок <strong>с <em>разными</em> символами</strong></h1><br/>",
        TestName = "Теги, вложенные в заголовок")]
    [TestCase(
        @"# Заголовки корректно разделяются \n # Символом переноса строки",
        @"<h1>Заголовки корректно разделяются </h1><br/> <h1>Символом переноса строки</h1><br/>",
        TestName = "Несколько заголовков")]
    [TestCase(
        @"Теги не __работают \n На 2 и более__ строк",
        @"Теги не __работают <br/> На 2 и более__ строк<br/>",
        TestName = "Тег на 2-е строки")]
    [TestCase(@"", @"<br/>", TestName = "Пустая строка не вызывает ошибок")]
    [TestCase(
        @"__Вложенность __нам __не _помеха_ !__ .__ ;__",
        @"<strong>Вложенность <strong>нам <strong>не <em>помеха</em> !</strong> .</strong> ;</strong><br/>",
        TestName = "Большая вложенность тегов")]
    public void Render_Should_ReturnCorrectHtml(string text, string expected)
    {
        var actual = MD.Render(text);
        actual.Should().Be(expected);
    }

    [Test]
    public void Render_Should_HaveLinearTimeComplexity()
    {
        var lyrics = @"# На _спящий_ город _опускается туман,\n
                       __Шалят ветра__ по по__двор__отням и дворам,\n
                       А _ нам всё __это _не_ __впервой__,\n
                       А нам доверено __судьбой__\n
                       _Оберегать_ на _здешних_ __улицах _покой_.__\n
                       # Да! А пожелай ты им __ни пуха ни пера.__\n
                       __Да!__ Пусть не по \_\_\_правилам\_\_\_ игра.\n
                       __Да!__ И если ____ завтра ____ будет круче, чем вчера,\n
                       _'Прорвёмся, '_ - ответят опера.\n
                       _Прорвёмся_, опера!\n
                       # Ещё вечерние зажгутся фонари,\n
                       __Туман_ __рассеется_ и что ни говори,\n
                       Сейчас бы __просто__ по 1_0_0 грамм\n
                       И __не мотаться__ по __дворам,\n
                       Но ранов__ато рас__слабляться операм.\n
                       # Да! А пожелай ты им _ни пуха ни пера._\n
                       __Да!__ Пусть __не по _прав_илам игра._\n
                       __Да!__ И если _завтра будет круче_, чем вчера,\n
                       _'Прорвёмся, '_ - ответят опера.\n
                       _Прорвём_ся, опера!\n";

        const int measuresCount = 1_000;
        const int growAmount = 5;
        const int epsilon = 1;

        var stopWatch = new Stopwatch();
        var temp = lyrics;

        stopWatch.Start();

        for (var i = 0; i < measuresCount; i++)
            MD.Render(lyrics);

        stopWatch.Stop();

        var firstAverageTime = stopWatch.Elapsed.TotalMilliseconds / measuresCount;

        stopWatch.Restart();

        for (var i = 0; i < growAmount - 1; i++)
            lyrics += temp;

        for (var i = 0; i < measuresCount; i++)
            MD.Render(lyrics);

        stopWatch.Stop();

        var actual = stopWatch.Elapsed.TotalMilliseconds / measuresCount;
        var expected = firstAverageTime * growAmount;

        Math.Abs(actual - expected).Should().BeLessOrEqualTo(epsilon);
    }
}